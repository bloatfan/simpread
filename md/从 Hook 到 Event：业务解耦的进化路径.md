> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/ZHNDAn9V2H_JHGgoaqIJPg)

昨天的文章评论区，有位朋友提了一个非常有代表性的问题，他的一句话点中了关键：“实际业务场景，远比示例复杂得多。”

这句话其实正好呼应了我在前几篇文章里反复强调的一点——**边界问题**。当业务规模、系统边界发生变化时，原本看起来合理的解决方案，适用性也会随之发生改变。

今天这篇文章，我们就从这个 “边界变化” 的角度出发，基于 Hook 的演进路径，聊一聊它在不同阶段应该如何使用，以及什么时候需要走向下一种解法。

很多团队在做业务解耦时，都会经历一个过程：  
一开始用 Hook，效果很好；  
后来 Hook 越加越多，逻辑越来越散；  
最后开始纠结：是不是该上 Event / MQ 了？

问题不在于 **Hook 对不对**，而在于：  
**你是否在用昨天的解法，解决今天规模的问题。**

本文将从真实业务演进的角度，系统梳理 **Hook → Event** 的架构演化路径，帮你判断：

*   什么时候 Hook 是最优解
    
*   什么时候 Hook 已经在拖慢系统
    
*   又该如何平滑过渡到 Event，而不是一刀切重构
    

一、先说结论：Hook 和 Event 不是对立关系
--------------------------

在很多技术讨论中，Hook 和 Event 常被放在对立面：

*   Hook = 紧耦合、同步、危险
    
*   Event = 解耦、异步、先进
    

但这是一种**过于粗糙的认知**。

更准确的说法是：

> **Hook 解决的是 “代码结构问题”，  
> Event 解决的是 “系统边界问题”。**

两者服务的维度，本来就不一样。

二、为什么 Hook 会成为很多系统的 “第一步解法”
---------------------------

### 1️⃣ 因为它足够贴近业务直觉

以最常见的场景为例：**订单创建**

```
创建订单 ├─ 风控校验 ├─ 校验库存 ├─ 落库 ├─ 发短信 ├─ 加积分
```

在这个阶段：

*   所有逻辑都在一个系统内
    
*   强一致性要求高
    
*   失败要能立刻反馈
    

Hook 的优势非常明显：

*   不引入新基础设施
    
*   调试简单
    
*   错误路径清晰
    

**这是 Hook 最擅长的战场。**

### 2️⃣ Hook 的真实价值：保护核心流程

一个设计良好的 Hook 框架，本质上是在做一件事：

> **把 “稳定的主流程” 和“频繁变化的扩展逻辑”隔离开。**

这能解决三个现实问题：

*   核心代码不再被需求反复污染
    
*   新需求的引入成本可控
    
*   团队协作边界更清晰
    

所以在**单体应用、早期微服务、核心链路内**，Hook 是一个性价比极高的方案。

三、Hook 什么时候开始 “变味”？
-------------------

问题通常不是突然出现的，而是**慢慢积累**。

### 🚨 信号一：After Hook 越来越多，而且越来越 “重”

一开始：

*   发短信
    
*   加积分
    

后来：

*   推送 BI
    
*   触发财务对账
    
*   同步搜索索引
    
*   通知外部系统
    

Hook 本该是 “扩展点”，却逐渐变成了**业务集散地**。

### 🚨 信号二：你开始害怕改 Hook

当你发现：

*   一个 Hook 的失败影响范围不清晰
    
*   不敢确定它会不会影响主流程
    
*   测试需要 Mock 半个系统
    

说明 Hook 已经**承担了超过它设计初衷的责任**。

### 🚨 信号三：Hook 开始跨系统

比如：

*   订单系统里的 Hook，调用了库存系统、营销系统、财务系统
    
*   网络抖动直接影响核心 RT
    

这时再坚持 Hook，本质上是在**用同步模型硬扛分布式复杂度**。

四、Event 出场的真正原因：系统边界发生了变化
-------------------------

当你的业务发展到一定阶段，变化的不只是 “逻辑复杂度”，而是：

*   团队规模
    
*   系统边界
    
*   发布节奏
    
*   可用性要求
    

此时，Event 的价值才真正显现。

### Event 真正解决的，是这三件事：

1.  **跨系统解耦**  
    
    发布、失败、扩容互不影响
    
2.  **最终一致性**  
    
    接受延迟，换取稳定性
    
3.  **系统自治**  
    
    每个系统只对自己的 Event 负责
    

五、一个真实可行的进化路径（非常重要）
-------------------

很多架构失败，不是选错方案，而是**跳跃式演进**。

### ❌ 错误示范

> “Hook 太复杂了，我们直接全量改成 MQ 吧。”

结果往往是：

*   事务边界混乱
    
*   排错成本指数上升
    
*   业务交付速度下降
    

### ✅ 正确路径：Hook → 内部 Event → 外部 Event

#### 第一阶段：同步 Hook（单体 / 核心链路）

*   强一致
    
*   快速失败
    
*   简单可控
    

#### 第二阶段：异步 Hook（系统内解耦）

```
AfterCreateHook → goroutine / task queue
```

*   主流程 RT 稳定
    
*   失败可降级
    
*   不引入分布式复杂度
    

#### 第三阶段：领域 Event（跨系统）

```
OrderCreatedEvent ├─ 积分系统消费 ├─ 通知系统消费 ├─ BI 系统消费
```

*   Hook 不再直接执行业务
    
*   Hook 只负责 **“发事件”**
    

六、一个非常重要的认知转变
-------------

> **Hook 不是 Event 的替代品，  
> 而是 Event 的 “缓冲层”。**

在成熟系统中，常见结构是：

```
核心流程 └─ Before Hook（强一致） └─ After Hook       └─ 发布 Event             └─ 下游系统异步消费
```

这样做的好处是：

*   核心流程依然可控
    
*   跨系统复杂度被推迟到边界之外
    
*   架构演进是连续的，而不是推倒重来
    

七、什么时候我会明确反对你用 Hook？
--------------------

作为一个长期做业务系统的人，我会在这几种情况下**明确反对继续加 Hook**：

1.  Hook 已经承担跨系统 SLA
    
2.  Hook 失败需要人工介入补偿
    
3.  Hook 内部逻辑已经接近一个完整子系统
    

这时你需要的不是 “更复杂的 Hook”，而是 **Event + 明确的业务契约**。

结语
--

架构设计真正困难的地方，从来不是 “用不用某种模式”，  
而是：

> **你是否清楚当前系统所处的阶段，  
> 以及下一步复杂度来自哪里。**

Hook 很好，Event 也很强。  
但只有放在正确的位置，它们才能真正释放价值。

如果你现在正在犹豫：  
“这个逻辑是该写 Hook，还是该发 Event？”

那说明——  
**你的系统，正在走向下一个成熟阶段。**

评论区留言 **「Hook」**：获取完整 Hook 框架源码（同步 / 异步 / 可观测）  
评论区留言**「Event」**：获取 Hook → Event 平滑演进的实战示例